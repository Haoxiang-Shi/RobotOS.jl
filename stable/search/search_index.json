{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"RobotOS.jl Documentation Overview Description This package enables interfacing Julia code with a ROS ( Robot Operating System ) system. It works by generating native Julia types for ROS types, the same as in C++ or Python, and then wrapping rospy through the PyCall package to get communication through topics, services, and parameters. Installation Pkg.add( RobotOS ) using RobotOS Contributing The package will hopefully continue to undergo substantial improvement. Please feel free to submit either an issue or pull request through github if you want to fix something or suggest a needed improvment, even if it's just to add an extra sentence in this README. Testing Currently, Pkg.test(\"RobotOS\") requires some bootstrapping to work properly. Before running Julia, make sure a ROS master is running and start the helper node by running the test/echonode.py file. Usage: Type Generation ROS types are brought into your program with the @rosimport macro which specifies a package and one or more types. The three valid syntax forms can be seen in these examples: @rosimport std_msgs.msg.Header @rosimport nav_msgs.srv: GetPlan @rosimport geometry_msgs.msg: PoseStamped, Vector3 @rosimport will import the python modules for the requested type and all its dependencies but the native Julia types are not created yet since any inter-module dependencies have to be resolved first. After the final @rosimport call, initiate the type generation with: rostypegen() The new types will be placed in newly created modules in Main , corresponding to the packages requested. For example, \"std_msgs/Header\" = std_msgs.msg.Header . After calling rostypegen() they can be interacted with just like regular modules with import and using statements bringing the generated type names into the local namespace. using .nav_msgs.msg import geometry_msgs.msg: Pose, Vector3 p = Path() v = Vector3(1.1,2.2,3.3) There is one special case, where the ROS type name conflicts with a built-in Julia type name (e.g., std_msgs/Float64 or std_msgs/String ). In these cases, the generated Julia type will have \"Msg\" appended to the name for disambiguation (e.g., std_msgs.msg.Float64Msg and std_msgs.msg.StringMsg ). An additional function, rostypereset() , resets the type generation process, possibly useful for development in the REPL. When invoked, new @rosimport calls will be needed to generate the same or different types, and previously generated modules will be overwritten after rostypegen() is called again. Keep in mind that names cannot be cleared once defined so if a module is not regenerated, the first version will remain. Compatibility with Package Precompilation As described above, by default rostypegen creates modules in Main \u2013 however, this behavior is incompatible with Julia package precompilation. If you are using RobotOS in your own module or package, as opposed to a script, you may reduce load-time latency (useful for real-life applications!) by generating the ROS type modules inside your package module using an approach similar to the example below: # MyROSPackage.jl module MyROSPackage using RobotOS @rosimport geometry_msgs.msg: Pose rostypegen(@__MODULE__) import .geometry_msgs.msg: Pose # ... end In this case, we have provided rostypegen with a root module ( MyROSPackage ) for type generation. The Julia type corresponding to geometry_msgs/Pose now lives at MyROSPackage.geometry_msgs.msg.Pose ; note the extra dot in import .geometry_msgs.msg: Pose . Usage: ROS API In general, the API functions provided directly match those provided in rospy, with few cosmetic differences. The rospy API functions can reviewed here: http://wiki.ros.org/rospy/Overview General Functions init_node(name::String; kwargs...) : Initialize node. Passes keyword arguments on to rospy directly. (Required) is_shutdown() : Check for ROS shutdown state. spin() : Wait for callbacks until shutdown happens. logdebug , loginfo , logwarn , logerr , logfatal all work as in rospy. Time Native Julia types Time and Duration are defined, both as a composite of an integral number of seconds and nanoseconds, as in rospy. Arithmetic and comparison operators are also defined. A Rate type is defined as a wrapper for the rospy Rate, which keeps loops running on a near fixed time interval. It can be constructed with a Duration object, or a floating-point value, specifying the loop rate in Hz. Other functions are: get_rostime() , RobotOS.now() : Current time as Time object. to_sec(time_obj) , convert(Float64, time_obj) : Convert Time or Duration object to floating-point number of seconds. to_nsec(time_obj) : Convert object to integral number of nanoseconds. rossleep(t) with t of type Duration , Rate , Real . Also sleep(t::Duration) and sleep(t::Rate) : Sleep the amount implied by type and value of the t parameter. Publishing Messages Publishing messages is the same as in rospy, except use the publish method, paired with a Publisher object. For example: using .geometry_msgs.msg pub = Publisher{PointStamped}( topic , queue_size = 10) #or... #pub = Publisher( topic , PointStamped, queue_size = 10) msg = PointStamped() msg.header.stamp = now() msg.point.x = 1.1 publish(pub, msg) The keyword arguments in the Publisher constructor are passed directly on to rospy so anything it accepts will be valid. Subscribing to a Topic Subscribing to a topic is the same as in rospy. When creating a Subscriber , an optional callback_args parameter can be given to forward on whenever the callback is invoked. Note that it must be passed as a tuple, even if there is only a single argument. And again, keyword arguments are directly forwarded. An example: using .sensor_msgs.msg cb1(msg::Imu, a::String) = println(a, : ,msg.linear_acceleration.x) cb2(msg::Imu) = println(msg.angular_velocity.z) sub1 = Subscriber{Imu}( topic , cb1, ( accel ,), queue_size = 10) #or... #sub1 = Subscriber( topic , Imu, cb1, ( accel ,), queue_size = 10) sub2 = Subscriber{Imu}( topic , cb2, queue_size = 10) spin() Using services ROS services are fully supported, including automatic request and response type generation. For the @rosimport call, use the plain service type name. After rostypegen() , the generated .srv submodule will contain 3 types: the plain type, a request type, and a response type. For example @rosimport nav_msgs.srv.GetPlan will create GetPlan , GetPlanRequest , and GetPlanResponse . To provide the service to other nodes, you would create a Service{GetPlan} object. To call it, a ServiceProxy{GetPlan} object. The syntax exactly matches rospy to construct and use these objects. For example, if myproxy is a ServiceProxy object, it can be called with myproxy(my_request) . Parameter Server get_param , set_param , has_param , and delete_param are all implemented in the RobotOS module with the same syntax as in rospy. Message Constants Message constants may be accessed using getproperty syntax. For example for visualization_msgs/Marker.msg we have: import .visualization_msgs.msg: Marker Marker.SPHERE == getproperty(Marker, :SPHERE) == 2 # true ROS Integration Since Julia code needs no prior compilation, it is possible to integrate very tightly and natively with a larger ROS system. Just make sure you: Keep your code inside your ROS packages as usual. Ensure your .jl script is executable (e.g., chmod a+x script.jl ) and has the hint to the Julia binary as the first line ( #!/usr/bin/env julia ). Now your Julia code will run exactly like any python script that gets invoked through rosrun or roslaunch . And since include takes paths relative to the location of the calling file, you can bring in whatever other modules or functions reside in your package from the single executable script. #!/usr/bin/env julia #main.jl in thebot_pkg/src using RobotOS include( BotSrc/Bot.jl ) using Bot #... Full example This example demonstrates publishing a random geometry_msgs/Point message at 5 Hz. It also listens for incoming geometry_msgs/Pose2D messages and republishes them as Points. #!/usr/bin/env julia using RobotOS @rosimport geometry_msgs.msg: Point, Pose2D rostypegen() using .geometry_msgs.msg function callback(msg::Pose2D, pub_obj::Publisher{Point}) pt_msg = Point(msg.x, msg.y, 0.0) publish(pub_obj, pt_msg) end function loop(pub_obj) loop_rate = Rate(5.0) while ! is_shutdown() npt = Point(rand(), rand(), 0.0) publish(pub_obj, npt) rossleep(loop_rate) end end function main() init_node( rosjl_example ) pub = Publisher{Point}( pts , queue_size=10) sub = Subscriber{Pose2D}( pose , callback, (pub,), queue_size=10) loop(pub) end if ! isinteractive() main() end Versions 0.1 : Initial release 0.2 : Changed type gen API and moved generated modules to Main 0.3 : Added service type generation and API 0.4 : Julia v0.4+ support only 0.5 : Docs website, Julia v0.5+ support only 0.6 : Julia v0.6+ support only","title":"Introduction"},{"location":"#robotosjl-documentation","text":"","title":"RobotOS.jl Documentation"},{"location":"#overview","text":"","title":"Overview"},{"location":"#description","text":"This package enables interfacing Julia code with a ROS ( Robot Operating System ) system. It works by generating native Julia types for ROS types, the same as in C++ or Python, and then wrapping rospy through the PyCall package to get communication through topics, services, and parameters.","title":"Description"},{"location":"#installation","text":"Pkg.add( RobotOS ) using RobotOS","title":"Installation"},{"location":"#contributing","text":"The package will hopefully continue to undergo substantial improvement. Please feel free to submit either an issue or pull request through github if you want to fix something or suggest a needed improvment, even if it's just to add an extra sentence in this README.","title":"Contributing"},{"location":"#testing","text":"Currently, Pkg.test(\"RobotOS\") requires some bootstrapping to work properly. Before running Julia, make sure a ROS master is running and start the helper node by running the test/echonode.py file.","title":"Testing"},{"location":"#usage-type-generation","text":"ROS types are brought into your program with the @rosimport macro which specifies a package and one or more types. The three valid syntax forms can be seen in these examples: @rosimport std_msgs.msg.Header @rosimport nav_msgs.srv: GetPlan @rosimport geometry_msgs.msg: PoseStamped, Vector3 @rosimport will import the python modules for the requested type and all its dependencies but the native Julia types are not created yet since any inter-module dependencies have to be resolved first. After the final @rosimport call, initiate the type generation with: rostypegen() The new types will be placed in newly created modules in Main , corresponding to the packages requested. For example, \"std_msgs/Header\" = std_msgs.msg.Header . After calling rostypegen() they can be interacted with just like regular modules with import and using statements bringing the generated type names into the local namespace. using .nav_msgs.msg import geometry_msgs.msg: Pose, Vector3 p = Path() v = Vector3(1.1,2.2,3.3) There is one special case, where the ROS type name conflicts with a built-in Julia type name (e.g., std_msgs/Float64 or std_msgs/String ). In these cases, the generated Julia type will have \"Msg\" appended to the name for disambiguation (e.g., std_msgs.msg.Float64Msg and std_msgs.msg.StringMsg ). An additional function, rostypereset() , resets the type generation process, possibly useful for development in the REPL. When invoked, new @rosimport calls will be needed to generate the same or different types, and previously generated modules will be overwritten after rostypegen() is called again. Keep in mind that names cannot be cleared once defined so if a module is not regenerated, the first version will remain.","title":"Usage: Type Generation"},{"location":"#compatibility-with-package-precompilation","text":"As described above, by default rostypegen creates modules in Main \u2013 however, this behavior is incompatible with Julia package precompilation. If you are using RobotOS in your own module or package, as opposed to a script, you may reduce load-time latency (useful for real-life applications!) by generating the ROS type modules inside your package module using an approach similar to the example below: # MyROSPackage.jl module MyROSPackage using RobotOS @rosimport geometry_msgs.msg: Pose rostypegen(@__MODULE__) import .geometry_msgs.msg: Pose # ... end In this case, we have provided rostypegen with a root module ( MyROSPackage ) for type generation. The Julia type corresponding to geometry_msgs/Pose now lives at MyROSPackage.geometry_msgs.msg.Pose ; note the extra dot in import .geometry_msgs.msg: Pose .","title":"Compatibility with Package Precompilation"},{"location":"#usage-ros-api","text":"In general, the API functions provided directly match those provided in rospy, with few cosmetic differences. The rospy API functions can reviewed here: http://wiki.ros.org/rospy/Overview","title":"Usage: ROS API"},{"location":"#general-functions","text":"init_node(name::String; kwargs...) : Initialize node. Passes keyword arguments on to rospy directly. (Required) is_shutdown() : Check for ROS shutdown state. spin() : Wait for callbacks until shutdown happens. logdebug , loginfo , logwarn , logerr , logfatal all work as in rospy.","title":"General Functions"},{"location":"#time","text":"Native Julia types Time and Duration are defined, both as a composite of an integral number of seconds and nanoseconds, as in rospy. Arithmetic and comparison operators are also defined. A Rate type is defined as a wrapper for the rospy Rate, which keeps loops running on a near fixed time interval. It can be constructed with a Duration object, or a floating-point value, specifying the loop rate in Hz. Other functions are: get_rostime() , RobotOS.now() : Current time as Time object. to_sec(time_obj) , convert(Float64, time_obj) : Convert Time or Duration object to floating-point number of seconds. to_nsec(time_obj) : Convert object to integral number of nanoseconds. rossleep(t) with t of type Duration , Rate , Real . Also sleep(t::Duration) and sleep(t::Rate) : Sleep the amount implied by type and value of the t parameter.","title":"Time"},{"location":"#publishing-messages","text":"Publishing messages is the same as in rospy, except use the publish method, paired with a Publisher object. For example: using .geometry_msgs.msg pub = Publisher{PointStamped}( topic , queue_size = 10) #or... #pub = Publisher( topic , PointStamped, queue_size = 10) msg = PointStamped() msg.header.stamp = now() msg.point.x = 1.1 publish(pub, msg) The keyword arguments in the Publisher constructor are passed directly on to rospy so anything it accepts will be valid.","title":"Publishing Messages"},{"location":"#subscribing-to-a-topic","text":"Subscribing to a topic is the same as in rospy. When creating a Subscriber , an optional callback_args parameter can be given to forward on whenever the callback is invoked. Note that it must be passed as a tuple, even if there is only a single argument. And again, keyword arguments are directly forwarded. An example: using .sensor_msgs.msg cb1(msg::Imu, a::String) = println(a, : ,msg.linear_acceleration.x) cb2(msg::Imu) = println(msg.angular_velocity.z) sub1 = Subscriber{Imu}( topic , cb1, ( accel ,), queue_size = 10) #or... #sub1 = Subscriber( topic , Imu, cb1, ( accel ,), queue_size = 10) sub2 = Subscriber{Imu}( topic , cb2, queue_size = 10) spin()","title":"Subscribing to a Topic"},{"location":"#using-services","text":"ROS services are fully supported, including automatic request and response type generation. For the @rosimport call, use the plain service type name. After rostypegen() , the generated .srv submodule will contain 3 types: the plain type, a request type, and a response type. For example @rosimport nav_msgs.srv.GetPlan will create GetPlan , GetPlanRequest , and GetPlanResponse . To provide the service to other nodes, you would create a Service{GetPlan} object. To call it, a ServiceProxy{GetPlan} object. The syntax exactly matches rospy to construct and use these objects. For example, if myproxy is a ServiceProxy object, it can be called with myproxy(my_request) .","title":"Using services"},{"location":"#parameter-server","text":"get_param , set_param , has_param , and delete_param are all implemented in the RobotOS module with the same syntax as in rospy.","title":"Parameter Server"},{"location":"#message-constants","text":"Message constants may be accessed using getproperty syntax. For example for visualization_msgs/Marker.msg we have: import .visualization_msgs.msg: Marker Marker.SPHERE == getproperty(Marker, :SPHERE) == 2 # true","title":"Message Constants"},{"location":"#ros-integration","text":"Since Julia code needs no prior compilation, it is possible to integrate very tightly and natively with a larger ROS system. Just make sure you: Keep your code inside your ROS packages as usual. Ensure your .jl script is executable (e.g., chmod a+x script.jl ) and has the hint to the Julia binary as the first line ( #!/usr/bin/env julia ). Now your Julia code will run exactly like any python script that gets invoked through rosrun or roslaunch . And since include takes paths relative to the location of the calling file, you can bring in whatever other modules or functions reside in your package from the single executable script. #!/usr/bin/env julia #main.jl in thebot_pkg/src using RobotOS include( BotSrc/Bot.jl ) using Bot #...","title":"ROS Integration"},{"location":"#full-example","text":"This example demonstrates publishing a random geometry_msgs/Point message at 5 Hz. It also listens for incoming geometry_msgs/Pose2D messages and republishes them as Points. #!/usr/bin/env julia using RobotOS @rosimport geometry_msgs.msg: Point, Pose2D rostypegen() using .geometry_msgs.msg function callback(msg::Pose2D, pub_obj::Publisher{Point}) pt_msg = Point(msg.x, msg.y, 0.0) publish(pub_obj, pt_msg) end function loop(pub_obj) loop_rate = Rate(5.0) while ! is_shutdown() npt = Point(rand(), rand(), 0.0) publish(pub_obj, npt) rossleep(loop_rate) end end function main() init_node( rosjl_example ) pub = Publisher{Point}( pts , queue_size=10) sub = Subscriber{Pose2D}( pose , callback, (pub,), queue_size=10) loop(pub) end if ! isinteractive() main() end","title":"Full example"},{"location":"#versions","text":"0.1 : Initial release 0.2 : Changed type gen API and moved generated modules to Main 0.3 : Added service type generation and API 0.4 : Julia v0.4+ support only 0.5 : Docs website, Julia v0.5+ support only 0.6 : Julia v0.6+ support only","title":"Versions"},{"location":"api/","text":"API Reference ROS Type Generation # RobotOS.@rosimport Macro . @rosimport Import ROS message or service types into Julia. Call rostypegen() after all @rosimport calls. Package or type dependencies are also imported automatically as needed. Example usages: @rosimport geometry_msgs.msg.PoseStamped @rosimport sensor_msgs.msg: Image, Imu @rosimport nav_msgs.srv.GetPlan # RobotOS.rostypegen Function . rostypegen(rosrootmod::Module=Main) Initiate the Julia type generation process after importing some ROS types. Creates modules in rootrosmod (default is Main ) with the same behavior as imported ROS modules in python. Should only be called once, after all @rosimport statements are done. # RobotOS.rostypereset Function . rostypereset() Clear out the previous @rosimport s, returning the type generation to its original state. Cannot do anything about already generated modules in Main . Publishing and Subscribing # RobotOS.Publisher Type . Publisher{T}(topic; kwargs...) Publisher(topic, T; kwargs...) Create an object to publish messages of type T on a topic. Keyword arguments are directly passed to rospy. # RobotOS.publish Function . publish(p::Publisher{T}, msg::T) Publish msg on p , a Publisher with matching message type. # RobotOS.Subscriber Type . Subscriber{T}(topic, callback, cb_args=(); kwargs...) Subscriber(topic, T, callback, cb_args=(); kwargs...) Create a subscription to a topic with message type T with a callback to use when a message is received, which can be any callable type. Extra arguments provided to the callback when invoked can be provided in the cb_args tuple. Keyword arguments are directly passed to rospy. Services # RobotOS.Service Type . Service{T}(name, callback; kwargs...) Service(name, T, callback; kwargs...) Create a service object that can receive requests and provide responses. The callback can be of any callable type. Keyword arguments are directly passed to rospy. # RobotOS.ServiceProxy Type . ServiceProxy{T}(name; kwargs...) ServiceProxy(name, T; kwargs...) Create a proxy object used to invoke a remote service. Use srv_proxy(msg_request) with the object to invoke the service call. Keyword arguments are directly passed to rospy. # RobotOS.wait_for_service Function . wait_for_service(srv_name; kwargs...) Block until the specified service is available. Keyword arguments are directly passed to rospy. Throws an exception if the waiting timeout period is exceeded. General ROS Functions # RobotOS.init_node Function . init_node(name; args...) Initialize this node, registering it with the ROS master. All arguments are passed on directly to the rospy init_node function. # RobotOS.is_shutdown Function . is_shutdown() Return the shutdown status of the node. # RobotOS.spin Function . spin() Block execution and process callbacks/service calls until the node is shut down. Time Handling # RobotOS.Time Type . Time(secs, nsecs), Time(), Time(t::Real) Object representing an absolute time from a fixed past reference point at nanosecond precision. Basic arithmetic can be performed on combinations of Time and Duration objects that make sense. For example, if t::Time and d::Duration , t+d will be a Time , d+d a Duration , t-d a Time , d-d a Duration , and t-t a Duration . # RobotOS.Duration Type . Duration(secs, nsecs), Duration(), Duration(t::Real) Object representing a relative period of time at nanosecond precision. Basic arithmetic can be performed on combinations of Time and Duration objects that make sense. For example, if t::Time and d::Duration , t+d will be a Time , d+d a Duration , t-d a Time , d-d a Duration , and t-t a Duration . # RobotOS.Rate Type . Rate(hz::Real), Rate(d::Duration) Used to allow a loop to run at a fixed rate. Construct with a frequency or Duration and use with rossleep or sleep . The rate object will record execution time of other work in the loop and modify the sleep time to compensate, keeping the loop rate as consistent as possible. # RobotOS.to_sec Function . to_sec(t) Return the value of a ROS time object in absolute seconds (with nanosecond precision) # RobotOS.to_nsec Function . to_nsec(t) Return the value of a ROS time object in nanoseconds as an integer. # RobotOS.now Function . RobotOS.now() Return the current ROS time as a Time object. # RobotOS.get_rostime Function . get_rostime() Return the current ROS time as a Time object. # RobotOS.rossleep Function . rossleep(t) Sleep and process callbacks for a number of seconds implied by the type and value of t , which may be a real-value, a Duration object, or a Rate object. # Base.sleep Function . sleep(t::Duration), sleep(t::Rate) Call rossleep with a Duration or Rate object. Use rossleep to specify sleep time directly. Parameters # RobotOS.get_param Function . get_param(param_name, default=nothing) Request the value of a parameter from the parameter server, with optional default value. If no default is given, throws a KeyError if the parameter cannot be found. # RobotOS.set_param Function . set_param(param_name, val) Set the value of a parameter on the parameter server. # RobotOS.has_param Function . has_param(param_name) Return a boolean specifying if a parameter exists on the parameter server. # RobotOS.delete_param Function . delete_param(param_name) Delete a parameter from the parameter server. Throws a KeyError if no such parameter exists. Logging # RobotOS.logdebug Function . logdebug, loginfo, logwarn, logerr, logfatal Call the rospy logging system at the corresponding message level, passing a message and other arguments directly. # RobotOS.loginfo Function . logdebug, loginfo, logwarn, logerr, logfatal Call the rospy logging system at the corresponding message level, passing a message and other arguments directly. # RobotOS.logwarn Function . logdebug, loginfo, logwarn, logerr, logfatal Call the rospy logging system at the corresponding message level, passing a message and other arguments directly. # RobotOS.logerr Function . logdebug, loginfo, logwarn, logerr, logfatal Call the rospy logging system at the corresponding message level, passing a message and other arguments directly. # RobotOS.logfatal Function . logdebug, loginfo, logwarn, logerr, logfatal Call the rospy logging system at the corresponding message level, passing a message and other arguments directly.","title":"API Reference"},{"location":"api/#api-reference","text":"","title":"API Reference"},{"location":"api/#ros-type-generation","text":"# RobotOS.@rosimport Macro . @rosimport Import ROS message or service types into Julia. Call rostypegen() after all @rosimport calls. Package or type dependencies are also imported automatically as needed. Example usages: @rosimport geometry_msgs.msg.PoseStamped @rosimport sensor_msgs.msg: Image, Imu @rosimport nav_msgs.srv.GetPlan # RobotOS.rostypegen Function . rostypegen(rosrootmod::Module=Main) Initiate the Julia type generation process after importing some ROS types. Creates modules in rootrosmod (default is Main ) with the same behavior as imported ROS modules in python. Should only be called once, after all @rosimport statements are done. # RobotOS.rostypereset Function . rostypereset() Clear out the previous @rosimport s, returning the type generation to its original state. Cannot do anything about already generated modules in Main .","title":"ROS Type Generation"},{"location":"api/#publishing-and-subscribing","text":"# RobotOS.Publisher Type . Publisher{T}(topic; kwargs...) Publisher(topic, T; kwargs...) Create an object to publish messages of type T on a topic. Keyword arguments are directly passed to rospy. # RobotOS.publish Function . publish(p::Publisher{T}, msg::T) Publish msg on p , a Publisher with matching message type. # RobotOS.Subscriber Type . Subscriber{T}(topic, callback, cb_args=(); kwargs...) Subscriber(topic, T, callback, cb_args=(); kwargs...) Create a subscription to a topic with message type T with a callback to use when a message is received, which can be any callable type. Extra arguments provided to the callback when invoked can be provided in the cb_args tuple. Keyword arguments are directly passed to rospy.","title":"Publishing and Subscribing"},{"location":"api/#services","text":"# RobotOS.Service Type . Service{T}(name, callback; kwargs...) Service(name, T, callback; kwargs...) Create a service object that can receive requests and provide responses. The callback can be of any callable type. Keyword arguments are directly passed to rospy. # RobotOS.ServiceProxy Type . ServiceProxy{T}(name; kwargs...) ServiceProxy(name, T; kwargs...) Create a proxy object used to invoke a remote service. Use srv_proxy(msg_request) with the object to invoke the service call. Keyword arguments are directly passed to rospy. # RobotOS.wait_for_service Function . wait_for_service(srv_name; kwargs...) Block until the specified service is available. Keyword arguments are directly passed to rospy. Throws an exception if the waiting timeout period is exceeded.","title":"Services"},{"location":"api/#general-ros-functions","text":"# RobotOS.init_node Function . init_node(name; args...) Initialize this node, registering it with the ROS master. All arguments are passed on directly to the rospy init_node function. # RobotOS.is_shutdown Function . is_shutdown() Return the shutdown status of the node. # RobotOS.spin Function . spin() Block execution and process callbacks/service calls until the node is shut down.","title":"General ROS Functions"},{"location":"api/#time-handling","text":"# RobotOS.Time Type . Time(secs, nsecs), Time(), Time(t::Real) Object representing an absolute time from a fixed past reference point at nanosecond precision. Basic arithmetic can be performed on combinations of Time and Duration objects that make sense. For example, if t::Time and d::Duration , t+d will be a Time , d+d a Duration , t-d a Time , d-d a Duration , and t-t a Duration . # RobotOS.Duration Type . Duration(secs, nsecs), Duration(), Duration(t::Real) Object representing a relative period of time at nanosecond precision. Basic arithmetic can be performed on combinations of Time and Duration objects that make sense. For example, if t::Time and d::Duration , t+d will be a Time , d+d a Duration , t-d a Time , d-d a Duration , and t-t a Duration . # RobotOS.Rate Type . Rate(hz::Real), Rate(d::Duration) Used to allow a loop to run at a fixed rate. Construct with a frequency or Duration and use with rossleep or sleep . The rate object will record execution time of other work in the loop and modify the sleep time to compensate, keeping the loop rate as consistent as possible. # RobotOS.to_sec Function . to_sec(t) Return the value of a ROS time object in absolute seconds (with nanosecond precision) # RobotOS.to_nsec Function . to_nsec(t) Return the value of a ROS time object in nanoseconds as an integer. # RobotOS.now Function . RobotOS.now() Return the current ROS time as a Time object. # RobotOS.get_rostime Function . get_rostime() Return the current ROS time as a Time object. # RobotOS.rossleep Function . rossleep(t) Sleep and process callbacks for a number of seconds implied by the type and value of t , which may be a real-value, a Duration object, or a Rate object. # Base.sleep Function . sleep(t::Duration), sleep(t::Rate) Call rossleep with a Duration or Rate object. Use rossleep to specify sleep time directly.","title":"Time Handling"},{"location":"api/#parameters","text":"# RobotOS.get_param Function . get_param(param_name, default=nothing) Request the value of a parameter from the parameter server, with optional default value. If no default is given, throws a KeyError if the parameter cannot be found. # RobotOS.set_param Function . set_param(param_name, val) Set the value of a parameter on the parameter server. # RobotOS.has_param Function . has_param(param_name) Return a boolean specifying if a parameter exists on the parameter server. # RobotOS.delete_param Function . delete_param(param_name) Delete a parameter from the parameter server. Throws a KeyError if no such parameter exists.","title":"Parameters"},{"location":"api/#logging","text":"# RobotOS.logdebug Function . logdebug, loginfo, logwarn, logerr, logfatal Call the rospy logging system at the corresponding message level, passing a message and other arguments directly. # RobotOS.loginfo Function . logdebug, loginfo, logwarn, logerr, logfatal Call the rospy logging system at the corresponding message level, passing a message and other arguments directly. # RobotOS.logwarn Function . logdebug, loginfo, logwarn, logerr, logfatal Call the rospy logging system at the corresponding message level, passing a message and other arguments directly. # RobotOS.logerr Function . logdebug, loginfo, logwarn, logerr, logfatal Call the rospy logging system at the corresponding message level, passing a message and other arguments directly. # RobotOS.logfatal Function . logdebug, loginfo, logwarn, logerr, logfatal Call the rospy logging system at the corresponding message level, passing a message and other arguments directly.","title":"Logging"}]}